## 目录

- [事务](#事务)
    - [传播行为](#传播行为)
    - [隔离级别](#隔离级别)
    - [分布式事务](#分布式事务)
    - [分布式ID](#分布式ID)
        - [雪花算法](#雪花算法)
        - [基于数据库](#基于数据库)
- [索引](#索引)
    - [优点](#优点)
    - [缺点](#缺点)
    - [索引如何提高查询速度](#索引如何提高查询速度)
- [三次握手与四次挥手](#三次握手与四次挥手)
    - [建立连接三次握手](#建立连接三次握手)
    - [关闭连接四次挥手](#关闭连接四次挥手)
- [URL到主页过程](#URL到主页过程)
- [转发与重定向](#转发与重定向)
- [Thread的sleep与wait](#Thread的sleep与wait)
- [equals与hashCode](#Equals与hashCode)
- [AOP](#AOP)


## 事务

### 传播行为

methodA事务方法调用methodB事务方法，methodB的事务传播行为决定methodB的事务如何运行。

* PROPAGATION_REQUIRED：当前事务存在，则加入该事务，不存在则新建事务。
* PROPAGATION_SUPPORTS：当前事务存在，则加入该事务，不存在则以非事务方式继续运行
* PROPAGATION_MANDATORY：当前事务存在，则加入该事务，不存在则抛异常。
* PROPAGATION_REQUIRES_NEW：创建新事务，当前事务存在则挂起。
* PROPAGATION_NOT_SUPPORTED：以非事务方式运行，当前事务存在则挂起。
* PROPAGATION_NEVER：以非事务方式运行，当前事务存在则抛异常。
* PROPAGATION_NESTED：嵌套新建事务。

### 隔离级别

* 读未提交，有脏读问题。
* 读已提交，写加行锁，解决脏读问题，有不可重复读问题。
* 可重复读，读加行锁，解决不可重复读问题，有幻读问题。
* 序列化，加表锁，解决幻读问题。

脏读：直接读数据，其他的一个transaction才写了一半的数据也可以读出来。  
不可重复读：在同一个transaction里面执行两次读，别人在中间写数据，两次读出来不一致。  
幻读：在同一个transaction里面执行两次select * from table，别人在中间新增数据，第二次比第一次读的多。

### 分布式事务

#### 两阶段提交

中间协调者确定各个事务完成

#### 三阶段提交

在两阶段提交基础之上，加入超时机制，事务的commit超时则自动提交。

#### 消息事务

将事务通过消息中间件进行异步解耦。

### 分布式ID

全局唯一、递增趋势

#### 雪花算法

64位long型整数，时间戳+机器ID+序列号，

#### 基于数据库

* 数据库自增ID
* 号段模式
* Redis



## 索引

### 优点

* 加快数据的检索速度
* 唯一索引保证数据的唯一性
* 加快表和表之间的连接

### 缺点

* 创建和维护索引会耗时，耗时随数据量增大而增大
* 索引占据物理空间

### 索引如何提高查询速度

将无序的数据变成相对有序的数据。


## 三次握手与四次挥手

### 建立连接三次握手

客户端–发送数据包  
服务端–发送ACK标志的数据包  
客户端–回复带有ACK标志的数据包

### 关闭连接四次挥手

客户端-发送关闭请求  
服务端-收到客户端的关闭请求，未关闭(数据未传输完毕)  
服务端-发送ACK确认关闭  
客户端-确认收到ACK  

2MSL:保证双工链接可靠关闭，保证重复数据段从网络中消失


## URL到主页过程

使用HTTP访问页面，DNS域名解析成IP地址，建立TCP连接，使用ARP地址解析协议，将IP地址转换为MAC地址。


## 转发与重定向

* forward：服务器行为，显示原URL，共享request数据，效率高
* redirect：客户端行为，显示新URL，不共享request数据，效率低


## Thread的sleep与wait

都可以暂停线程的执行。

* sleep：不释放锁，执行完后自动被唤醒，通常用于线程的暂停
* wait：释放锁，唤醒需要别的线程调用同以对象的notify/notifyAll，通常用于线程间的通信


## Equals与hashCode

### equals

* ==：基本数据类型比较的是值，引用数据类型比较的是内存地址
* equals：没有重写equals，等价于==；重写了equals，比较对象的内容相等

String类和字符数组都被final修饰，String的引用可变，反射可改变数据值。

### hashCode

hashCode作用是获取hash码，hash码用来确定对象在hash表中的索引位置，减少equals的次数。  
Object的hashCode是本地方法，将对象的内存地址转换为整数返回。

重写equals要重写hashCode：相等的对象必须具有相同的hash码


## AOP

动态代理实现

* JDK：对接口代理，通过反射调用被拦截方法
* CGLIB：对类代理，采用FastClass机制，对一个类的方法建立索引，通过索引直接调用相应方法