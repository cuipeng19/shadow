## 目录

- [Java内存区域](#Java内存区域)
    - [概述](#概述)
    - [运行时数据区](#运行时数据区)
        - [程序计数器](#程序计数器)
        - [Java虚拟机栈](#Java虚拟机栈)
        - [本地方法栈](#本地方法栈)
        - [堆](#堆)
        - [方法区](#方法区)
        - [运行时常量池](#运行时常量池)
        - [直接内存](#直接内存)
    - [HotSpot虚拟机](#HotSpot虚拟机)
        - [对象的创建](#对象的创建)
        - [对象的内存布局](#对象的内存布局)
        - [对象的访问定位](#对象的访问定位)
- [JVM垃圾回收](#JVM垃圾回收)
    - [内存分配与回收](#内存分配与回收)
    - [对象死亡](#对象死亡)
        - [判断对象无效](#判断对象无效)
        - [引用类型](#引用类型)
    - [垃圾收集算法](#垃圾收集算法)
    - [垃圾收集器](#垃圾收集器)
- [JDK监控和故障处理](#JDK监控和故障处理)

## Java内存区域

![运行时数据区](../picture/jvm/Java运行时数据区域JDK1.8.png)

### 概述

内存控制权交给java虚拟机，每一个new操作不用delete/free，了解虚拟机怎样使用内存，内存泄漏和内存溢出问题排查更容易。

### 运行时数据区

#### 程序计数器

* 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如顺序执行、选择、循环、异常处理。
* 在多线程情况下，程序计数器用于记录当前线程执行位置，从而当前线程被切换回来的时候能够知道上次运行到哪。

#### Java虚拟机栈

由一个个栈帧组成，每个栈帧包括：局部变量表、操作数栈、动态连接、方法出口信息。  
局部变量表存放编译期间的基本数据类型（byte、short、int、long、float、double、char、boolean），对象引用（reference）  

#### 本地方法栈

执行本地方法

#### 堆

存放对象实例  
分为新生代（Eden、Survivor）、老年代

#### 方法区

non-heap（非堆），存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

#### 运行时常量池

存放编译器生成的字面量和符号引用

#### 直接内存

避免在Java堆和Native堆之间来回复制数据，内存的分配不会受到Java堆的限制。

### HotSpot虚拟机

#### 对象的创建

对象的创建过程  
* 类加载检查  
虚拟机遇到一条new指令时，检查指令的参数是否能在常量池中定位到这个类的符号引用，检查这个类是否被加载、解析、初始化。
如果没有则先进行类加载。
* 分配内存  
对象所需内存大小在类加载完后便可确定，分配内存是把确定的内存大小在Java堆中划分出来。  
垃圾收集器的压缩整理功能决定Java堆是否规整，规整决定分配方式。  
指针碰撞：堆内存规整，用过的内存整合到一边，没用过的在另一边，中间有一个分解值指针，指针向没用过的方向移动内存大小位置。  
空闲列表：堆内存不规整，虚拟机维护一个列表，列表记录那些内存可用，分配的时候找一块足够大的内存并更新记录。
* 初始化零值  
虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）,这一步保证了对象的实例可以不赋值直接使用。
* 设置对象头  
虚拟机对对象进行设置，例如对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄。
* 执行init方法  
初始化

#### 对象的内存布局

* 对象头  
对象自身的运行时数据：哈希码、GC分代年龄、锁状态标志  
类型指针：指向类的元数据，用来确定对象是哪个类的实例
* 实例数据  
存储各种类型字段的内容
* 对齐填充  
占位作用，虚拟机的自动内存管理系统规定对象起始地址是8字节的整数倍

#### 对象的访问定位

通过栈上的reference操作堆上的实例数据。
* 句柄  
Java堆中划分一块内存作为句柄池，reference中存储的是对象的句柄地址，包含对象实例指针、对象类型指针。
![句柄](../picture/jvm/句柄.jpg)
* 直接指针  
reference中存储的是对象的地址，包含对象实例、对象类型指针。
![直接指针](../picture/jvm/直接指针.png)


## JVM垃圾回收

### 内存分配与回收

Java的自动内存管理是针对对象内存的分配和回收，主要针对堆内存。  
进一步划分堆是更好的回收、分配内存。
![堆空间的基本结构](../picture/jvm/堆空间的基本结构.png)  
对象在Eden分配，新生代垃圾回收后，存活的对象进入Survivor，并且年龄加1，当年龄达到一定程度（默认15）晋升老年代。  
堆内存分配策略：有限在Eden分配，大对象直接进入老年代，长期存活的对象将进入老年代。  
-XX:PrintGCDetails打印GC信息
* Partial GC  
young GC：只进行young gen的GC，eden分配满的时候触发  
Old GC：只进行old gen的GC，只有CMS的concurrent collection是这个模式  
Mixed GC：对整个young gen和部分old gen的GC，只有G1有这个模式
* Full GC  
收集整个堆。  
young GC的晋升大小大于old gen的剩余空间，不触发young GC转而触发Full GC
Parallel Scavenge框架下先执行一次young GC，以期降低full GC的暂停时间  
old gen使用量超过触发比例

### 对象死亡

#### 判断对象无效

* 引用计数法  
对象中添加一个引用计数器，被引用一次加1，引用失效减1，计数为0时对象不再被使用。  
不能解决循环引用问题。
* 可达性分析算法  
GC Roots作为起点，对象可到达起点则可用。  
可作为GC Roots的对象：虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象。

#### 引用类型

* 强引用 Strong Reference  
垃圾回收器不会回收
* 软引用 Soft Reference  
内存空间足够不会回收，内存不足会回收
* 弱引用 Weak Reference  
垃圾回收时，不管内存空间够不够，都会回收
* 虚引用 Phantom Reference  
不决定对象的生命周期，用来跟踪对象别垃圾回收的活动

### 垃圾收集算法

* 标记-清除算法  
标记存活的对象，完成后清除未标记的对象。  
效率慢，产生大量不连续碎片。
* 复制算法  
将内存分为大小相同的两块，每次使用其中的一块，一块使用完后，将存活的对象复制到另一块，之前的内存一次清除。
* 标记-整理算法  
标记存活的对象，并移向一端，直接清理掉边界以外的内存。
* 分代收集算法  
新生代对象存活几率低，采用复制算法。  
老年代对象存活几率高，而且没有额外的空间进行分配担保，采用标记-整理或标记-清除算法。

### 垃圾收集器

* Serial收集器  
单线程，分代收集算法，垃圾收集时暂停其他所有线程(Stop THe World)。
* ParNew收集器  
Serial的多线程版本。
* Parallel Scavenge收集器  
新生代并行，老年代串行，JDK8的默认收集器，查看命令java -XX:+PrintCommandLineFlags -version。
* Serial Old收集器  
Serial的老年代版本。
* Parallel Old收集器  
Parallel Scavenge的老年代版本。
* CMS收集器  
获取最短停顿时间为目标，实现垃圾收集线程与用户线程同时工作。低停顿，并发收集。  
![CMS](../picture/jvm/CMS收集器.png)  
缺点：标记-清除算法导致大量空间碎片，CPU资源敏感。
* G1收集器  
分代收集，标记整理，可预测停顿。  
后台维护一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。

## JDK监控和故障处理

