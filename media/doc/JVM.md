## 目录

- [Java内存区域](#Java内存区域)
    - [概述](#概述)
    - [运行时数据区](#运行时数据区)
        - [程序计数器](#程序计数器)
        - [Java虚拟机栈](#Java虚拟机栈)
        - [本地方法栈](#本地方法栈)
        - [堆](#堆)
        - [方法区](#方法区)
        - [运行时常量池](#运行时常量池)
        - [直接内存](#直接内存)
    - [HotSpot虚拟机](#HotSpot虚拟机)
        - [对象的创建](#对象的创建)
        - [对象的内存布局](#对象的内存布局)
        - [对象的访问定位](#对象的访问定位)

## Java内存区域

![运行时数据区](../picture/jvm/Java运行时数据区域JDK1.8.png)

### 概述

内存控制权交给java虚拟机，每一个new操作不用delete/free，了解虚拟机怎样使用内存，内存泄漏和内存溢出问题排查更容易。

### 运行时数据区

#### 程序计数器

* 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如顺序执行、选择、循环、异常处理。
* 在多线程情况下，程序计数器用于记录当前线程执行位置，从而当前线程被切换回来的时候能够知道上次运行到哪。

#### Java虚拟机栈

由一个个栈帧组成，每个栈帧包括：局部变量表、操作数栈、动态连接、方法出口信息。  
局部变量表存放编译期间的基本数据类型（byte、short、int、long、float、double、char、boolean），对象引用（reference）  

#### 本地方法栈

执行本地方法

#### 堆

存放对象实例  
分为新生代（Eden、Survivor）、老年代

#### 方法区

non-heap（非堆），存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

#### 运行时常量池

存放编译器生成的字面量和符号引用

#### 直接内存

避免在Java堆和Native堆之间来回复制数据，内存的分配不会受到Java堆的限制。

### HotSpot虚拟机

#### 对象的创建

对象的创建过程  
* 类加载检查  
虚拟机遇到一条new指令时，检查指令的参数是否能在常量池中定位到这个类的符号引用，检查这个类是否被加载、解析、初始化。
如果没有则先进行类加载。
* 分配内存  
对象所需内存大小在类加载完后便可确定，分配内存是把确定的内存大小在Java堆中划分出来。  
垃圾收集器的压缩整理功能决定Java堆是否规整，规整决定分配方式。  
指针碰撞：堆内存规整，用过的内存整合到一边，没用过的在另一边，中间有一个分解值指针，指针向没用过的方向移动内存大小位置。  
空闲列表：堆内存不规整，虚拟机维护一个列表，列表记录那些内存可用，分配的时候找一块足够大的内存并更新记录。
* 初始化零值  
虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）,这一步保证了对象的实例可以不赋值直接使用。
* 设置对象头  
虚拟机对对象进行设置，例如对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄。
* 执行init方法  
初始化

#### 对象的内存布局

* 对象头  
对象自身的运行时数据：哈希码、GC分代年龄、锁状态标志  
类型指针：指向类的元数据，用来确定对象是哪个类的实例
* 实例数据  
存储各种类型字段的内容
* 对齐填充  
占位作用，虚拟机的自动内存管理系统规定对象起始地址是8字节的整数倍

#### 对象的访问定位

通过栈上的reference操作堆上的实例数据。
* 句柄  
Java堆中划分一块内存作为句柄池，reference中存储的是对象的句柄地址，包含对象实例指针、对象类型指针。
![句柄](../picture/jvm/句柄.jpg)
* 直接指针  
reference中存储的是对象的地址，包含对象实例、对象类型指针。
![直接指针](../picture/jvm/直接指针.png)

